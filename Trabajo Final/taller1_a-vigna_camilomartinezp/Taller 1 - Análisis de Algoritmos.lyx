#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{xmpmulti}
\usepackage{algorithm,algpseudocode}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
eqs-within-sections
figs-within-sections
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\lang spanish
Taller Guiado - Análisis de Algoritmos
\end_layout

\begin_layout Author

\lang spanish
Alberto Luis Vigna Arroyo, Camilo José Martinez
\end_layout

\begin_layout Date

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\begin_layout Abstract

\lang spanish
En este documento se presenta el análisis del algoritmo de ordenamiento
 Bubble Sort, Insertion Sort y Quick Sort.
 Cada uno de estos algoritmos aborda el problema de ordenar una lista de
 elementos, pero difieren en sus enfoques y eficiencias.
 A continuación, se proporciona un resumen de los aspectos más destacados
 de cada algoritmo, destacando sus características, ventajas y desventajas,
 así como sus complejidades temporales y espaciales.
 Este análisis permite comprender mejor la idoneidad y el rendimiento de
 cada algoritmo en diferentes contextos y escenarios.
\end_layout

\begin_layout Part

\lang spanish
Análisis y diseño del problema
\end_layout

\begin_layout Section

\lang spanish
Análisis
\end_layout

\begin_layout Standard

\lang spanish
El problema, informalmente, se puede describir como calcular para una secuencia
 de elementos 
\begin_inset Formula $S=\left\langle a_{1},a_{2},a_{3},\cdots,a_{n}\right\rangle $
\end_inset

 en donde 
\begin_inset Formula $\forall_{i}a_{i}\in$
\end_inset

 
\begin_inset Formula $\mathbb{T}$
\end_inset

 y 
\begin_inset Formula $\mathbb{T}$
\end_inset

 existe una relación de orden parcial 
\begin_inset Formula $'\leq'$
\end_inset

, una secuencia ordenada, es decir una permutación 
\begin_inset Formula $S=\left\langle a'_{1},a'_{2},a'_{3},\cdots,a'_{n}\right\rangle $
\end_inset

 en donde 
\begin_inset Formula $a_{i}\leq a'_{i+1}$
\end_inset

 y 
\begin_inset Formula $a'_{i}\in S$
\end_inset

.
\end_layout

\begin_layout Section

\lang spanish
Diseño
\end_layout

\begin_layout Standard

\lang spanish
Con las observaciones presentadas en el análisis anterior, podemos escribir
 el diseño de un algoritmo que solucione el problema .
 A veces este diseño se conoce como el 
\begin_inset Quotes cld
\end_inset

contrato
\begin_inset Quotes crd
\end_inset

 del algoritmmos o las 
\begin_inset Quotes cld
\end_inset

precondiciones
\begin_inset Quotes crd
\end_inset

 y 
\begin_inset Quotes cld
\end_inset

poscondiciones
\begin_inset Quotes crd
\end_inset

 del algoritmo.
 El diseño se compone de entradas y salidas:
\end_layout

\begin_layout Definition*

\lang spanish
Entradas:
\end_layout

\begin_layout Enumerate

\lang spanish
\begin_inset Formula $S=\left\langle a_{1},a_{2},a_{3},\cdots,a_{n}\right\rangle $
\end_inset

, en donde 
\begin_inset Formula $\forall,$
\end_inset

a 
\begin_inset Formula $\in\mathbb{T}$
\end_inset

 y en 
\begin_inset Formula $\mathbb{T}$
\end_inset

 existe una relación de orden parcial 
\begin_inset Formula $\leq$
\end_inset

.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Definition*

\lang spanish
Salidas:
\end_layout

\begin_layout Enumerate

\lang spanish
\begin_inset Formula $S'=\left\langle a'_{1},a'_{2},a'_{3},\cdots,a'_{n}\right\rangle $
\end_inset

 en donde 
\begin_inset Formula $a'_{i}\leq a'_{i+1}$
\end_inset

 y 
\begin_inset Formula $a'_{i}\in S$
\end_inset

.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Part

\lang spanish
Algoritmos
\end_layout

\begin_layout Section

\lang spanish
Opción algoritmo 1 - BubbleSort
\end_layout

\begin_layout Subsection

\lang spanish
Algoritmo
\end_layout

\begin_layout Standard

\lang spanish
Este algoritmo se basa en el principio de comparar pares de elementos adyacentes
 en una lista y realizar intercambios si es necesario, repitiendo este proceso
 hasta que la lista esté completamente ordenada.
 En cada iteración se va recorriendo la lista y verificando si el elementos
 
\begin_inset Formula $a_{i}>a_{i+1}.$
\end_inset

 Si este lo es los elementos se 
\begin_inset Quotes eld
\end_inset

rotan
\begin_inset Quotes erd
\end_inset

 para que estos vayan siendo ordenados.
 
\end_layout

\begin_layout Standard
En el algoritmo 1 se puede encontrar la implementación de este algoritmo.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

BubbleSort
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
State
\end_layout

\end_inset


\begin_inset Formula $n\leftarrow|S|$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $i\leftarrow1$
\end_inset

 
\begin_inset Formula $\mathbf{to}$
\end_inset

 
\begin_inset Formula $n$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $j\leftarrow1$
\end_inset

 
\begin_inset Formula $\mathbf{to}$
\end_inset

 
\begin_inset Formula $n-i$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $S\left[j\right]>S\left[j+1\right]$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $variableTemporal=S[j]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $S\left[j\right]=S\left[j+1\right]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $S\left[j+1\right]=variableTemporal$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout
BubbleSort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\lang spanish
Complejidad
\end_layout

\begin_layout Standard

\lang spanish
El algoritmo 
\noun on
Bubble Sort
\noun default
 tiene órden de complejidad 
\begin_inset Formula $O(n^{2}$
\end_inset

).
 Esto se debe a que emplea dos bucles anidados, donde el bucle externo realiza
 
\begin_inset Formula $n$
\end_inset

 iteraciones, y el bucle interno realiza comparaciones y posibles intercambios
 adyacentes.
 Esta estructura cuadrática resulta en un rendimiento menos eficiente, especialm
ente para conjuntos de datos extensos.
\end_layout

\begin_layout Subsection

\lang spanish
Invariante 
\end_layout

\begin_layout Standard

\lang spanish
En cada iteración del bucle externo, el elemento más grande entre los elementos
 no ordenados está ubicado en la última posición correcta de la lista.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Inicio
\series default
\bar default
: Antes de iniciar el ordenamiento consideramos que la parte derecha de
 la lista (desde el índice 
\begin_inset Formula $i$
\end_inset

 hasta 
\begin_inset Formula $n$
\end_inset

) contiene los elementos más grandes y ya está ordenada.
 Inicialmente, 
\begin_inset Formula $i=1$
\end_inset

, por lo que la lista completa se toma como no ordenada.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Avance
\series default
\bar default
: En cada iteración del bucle externo, el bucle interno compara y posiblemente
 intercambia elementos adyacentes.
 Esta operación mueve el elemento más grande a la posición 
\begin_inset Formula $n-i$
\end_inset

, manteniendo la parte derecha de la lista ordenada.
 El valor de 
\begin_inset Formula $i$
\end_inset

 se incrementa después de cada iteración del bucle externo.
 Si no hay intercambios durante una iteración completa del bucle externo,
 significa que la lista está completamente ordenada y el algoritmo se detiene.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Terminación: 
\series default
\bar default
El proceso continua hasta que 
\begin_inset Formula $i=n$
\end_inset

, momentos en el cual se ha completado el ordenamiento de la lista.
\end_layout

\begin_layout Subsection

\lang spanish
Notas de implementación
\end_layout

\begin_layout Standard

\lang spanish
Para la implementación de este algoritmo se hizo uso del lenguaje interpretado
 Python.
 En este caso, se nos brindó dicho código que fue escrito por el profesor
 Leonardo Florez El código para este algoritmo se ubica en la carpeta 
\begin_inset Formula $‘Código/Taller1–Análisisdealgoritmos/sort/bubble_{s}ort.py’$
\end_inset

.
\end_layout

\begin_layout Standard

\lang spanish
La implementación se encuentra entre la línea 11 y la 15.
 
\end_layout

\begin_layout Section

\lang spanish
Opción algoritmo 2 - Insertion Sort
\end_layout

\begin_layout Subsection

\lang spanish
Algoritmo
\end_layout

\begin_layout Standard
Este algoritmo se basa en el principio de iterar sobre una lista 
\begin_inset Formula $S$
\end_inset

 de 
\begin_inset Formula $n$
\end_inset

 elementos, donde 
\begin_inset Formula $n=\left|S\right|$
\end_inset

.
 La idea es que este algorimo empiece desde el segundo elemento 
\begin_inset Formula $(i=2)$
\end_inset

 y que en cada iteración se compare 
\begin_inset Formula $S\left[i\right]$
\end_inset

 con los elementos anteriores (es decir, 
\begin_inset Formula $S\left[i-1\right],S\left[i-2\right],\ldots$
\end_inset

), desplazándolos hacia la derecha mientras 
\begin_inset Formula $S[i]$
\end_inset

 sea menor.
 La meta es insertar 
\begin_inset Formula $S[i]$
\end_inset

 en la posición correcta, asegurando que la sublista 
\begin_inset Formula $S[1:i]$
\end_inset

 esté ordenada después de cada iteración.
\end_layout

\begin_layout Standard
En el algoritmo 2 se puede encontrar la implementación de este algoritmo.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

InsertionSort
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $S$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
State
\end_layout

\end_inset


\begin_inset Formula $n\leftarrow|S|$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $i\leftarrow2$
\end_inset

 
\begin_inset Formula $\mathbf{to}$
\end_inset

 
\begin_inset Formula $n$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $key=S[i]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $j=i-1$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
While
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $j>0$
\end_inset

 
\begin_inset Formula $and$
\end_inset

 
\begin_inset Formula $S[j]>key$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $S[j+1]=S[j]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $j=j+1$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndWhile
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $S\left[j+1\right]=key$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout
InsertionSort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\lang spanish
Complejidad
\end_layout

\begin_layout Standard

\lang spanish
La complejidad del algoritmos de Insertion Sort es de 
\begin_inset Formula $O(n^{2})$
\end_inset

, lo que significa que el tiempo de ejecución crece cuadráticamente con
 el tamaño de la lista.
 En el peor caso, donde la lista está en orden descendente, cada elemento
 requiere comparaciones y desplazamientos en cada iteración, resultando
 en aproximadamente 
\begin_inset Formula $\frac{n^{2}}{2}$
\end_inset

 operaciones.
 Aunque es eficiente para listas pequeñas o casi ordenadas, Insertion Sort
 puede volverse ineficiente para conjuntos de datos más grandes debido a
 su complejidad cuadrática.
\end_layout

\begin_layout Subsection

\lang spanish
Invariante
\end_layout

\begin_layout Standard
Después de cada iteración del bucle externo, la sublista que va desde el
 inicio de la lista hasta el índice actual 
\begin_inset Formula $S[1:i\text{]}$
\end_inset

 está ordenada.
 Esto implica que los elementos en la sublista ya están en sus posiciones
 finales correctas en el contexto de la lista completa.
 El algoritmo, en cada paso, inserta el elemento actual en su posición correcta,
 desplazando los elementos mayores a la derecha para mantener la ordenación.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Inicio
\series default
\bar default
: Antes de iniciar el bucle externo, la sublista inicial 
\begin_inset Formula $S[1:1]$
\end_inset

 consiste en un solo elemento, y por lo tanto, está trivialmente ordenada.
 El invariante se cumple inicialmente, ya que no hay elementos previos para
 comparar.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Avance
\series default
\bar default
: Durante cada iteración del bucle externo, el algoritmo selecciona un nuevo
 elemento 
\begin_inset Formula $S[i]$
\end_inset

y lo compara con los elementos anteriores 
\lang english
(es decir, 
\begin_inset Formula $S\left[i-1\right],S\left[i-2\right],\ldots$
\end_inset

).

\lang spanish
 El bucle interno desplaza los elementos mayores hacia la derecha, creando
 espacio para insertar 
\begin_inset Formula $S[i]$
\end_inset

 en su posición correcta.
 Al finalizar la iteración, la sublista 
\begin_inset Formula $S[1:i]$
\end_inset

 está ordenada, cumpliendo así el invariante.
 El avance garantiza que, después de cada iteración, la porción de la lista
 considerada hasta el momento sigue estando en orden.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Terminación: 
\series default
\bar default
Cuando el bucle externo ha recorrido toda la lista, la sublista completa
 
\begin_inset Formula $S[1:n]$
\end_inset

 está ordenada.
 El invariante se mantiene hasta el final del proceso, asegurando que, en
 cada paso del bucle externo, la sublista parcial se mantenga ordenada.
 Por lo tanto, al terminar, el invariante garantiza que la lista completa
 esté ordenada.
\end_layout

\begin_layout Subsection

\lang spanish
Notas de implementación
\end_layout

\begin_layout Standard

\lang spanish
Para la implementación de este algoritmo se hizo uso del lenguaje interpretado
 Python.
 En este caso, se nos brindó dicho código que fue escrito por el profesor
 Leonardo Florez El código para este algoritmo se ubica en la carpeta 
\begin_inset Formula $‘Código/Taller1–Análisisdealgoritmos/sort/insertion_{s}ort.py’$
\end_inset

.
 
\end_layout

\begin_layout Standard

\lang spanish
La implementación se encuentra entre la línea 11 y la 19.
 
\end_layout

\begin_layout Section

\lang spanish
Opción algoritmo 3 - Quick Sort
\end_layout

\begin_layout Subsection

\lang spanish
Algortimo
\end_layout

\begin_layout Standard

\lang spanish
El algoritmo de QuickSort consiste en organizar una lista 
\begin_inset Formula $S$
\end_inset

.
 Inicialmente el algoritmo selecciona un elementos comúnmente llamado 
\begin_inset Formula $"pivot"$
\end_inset

 de la lista, particionando los demás elementos en dos sublistas: aquella
 que contiene los elementos que son menores al pivot 
\begin_inset Formula $\mathit{(S_{1}=\{x\in S|x<pivot\})}$
\end_inset

 y aquellos elementos que son mayores 
\begin_inset Formula $\mathit{(S_{1}=\{x\in S|x>pivot\})}$
\end_inset

.
 Este enfoque divide la tarea en subproblemas más pequeños y se combina
 para lograr la ordenación completa.
 Se aplica el mismo proceso de manera recursiva a ambas sublistas, seleccionando
 nuevos pivotes y dividiéndolas hasta que toda la lista esté ordenada.
 El éxito de QuickSort radica en la elección eficiente del pivot y la partición
 de la lista en torno a él, reduciendo así el problema original en subproblemas
 más pequeños.
\end_layout

\begin_layout Standard

\lang spanish
El paso clave es la elección del pivot y la partición de la lista en torno
 a él.
 Un pivot bien elegido mejora el rendimiento del algoritmo.
 QuickSort es eficiente en la práctica y a menudo supera a otros algoritmos
 de ordenamiento como Merge Sort debido a su menor número de intercambios.
\end_layout

\begin_layout Standard
En el algoritmo 3 se puede encontrar la implementación de este algoritmo.
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

QuickSort
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $S,inicio,fin$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $inicio<fin$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
State
\end_layout

\end_inset


\begin_inset Formula $pivotIndex=particion(S,inicio,fin)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
State
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
State
\end_layout

\end_inset


\begin_inset Formula $QuickSort(S,inicio,pivotIndex-1)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout

  
\backslash
State
\end_layout

\end_inset


\begin_inset Formula $QuickSort(S,pivotIndex+1,fin)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

particion
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $S,inicio,fin$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $pivot=S[fin]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $pivotIndex=inicio-1$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
For
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $i\leftarrow inicio$
\end_inset

 
\begin_inset Formula $\mathbf{to}$
\end_inset

 
\begin_inset Formula $fin-1$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
If
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $S[i]\leq pivot$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $pivotIndex=pivotIndex+1$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $intercambio(S,pivotIndex,i)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $intercambio(S,pivotIndex+1,fin)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $return(pivotIndex+1)$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Procedure
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

intercambiar
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset


\begin_inset Formula $S,i,j$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $temp=S[i]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $S[i]=S[j]$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
State
\end_layout

\end_inset


\begin_inset Formula $S[j]=temp$
\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EndProcedure
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang spanish
\begin_inset Caption Standard

\begin_layout Plain Layout
QuickSort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Complejidad
\end_layout

\begin_layout Standard
Inicialmente tenemos que encontrar las complejidades de las funciones auxiliares.
 La función 
\begin_inset Quotes eld
\end_inset

particion
\begin_inset Quotes erd
\end_inset

 es de complejidad 
\begin_inset Formula $O(n)$
\end_inset

.
 Esta complejidad es posible encontrarla gracias al método de inspección.
 Por otro lado la función 
\begin_inset Quotes eld
\end_inset

intercambiar
\begin_inset Quotes erd
\end_inset

 es de complejidad 
\begin_inset Formula $O(1)$
\end_inset

.
\end_layout

\begin_layout Standard
Siguiendo con el análisis, para encontrar la complejidad de el algoritmo
 en general haremos uso de el teorema maestro.
 
\end_layout

\begin_layout Subsubsection
Mejor Caso
\end_layout

\begin_layout Standard
Este algoritmo cuenta con la siguiente función de recurrencia: 
\begin_inset Formula 
\[
T(n)=2T(\frac{n}{2})+n
\]

\end_inset


\end_layout

\begin_layout Standard
Usando el teorema maestro se sigue el siguiente procedimiento:
\end_layout

\begin_layout Itemize
Encontrar el 
\begin_inset Formula $C_{critico}$
\end_inset

: 
\begin_inset Formula 
\[
log_{2}2=1
\]

\end_inset


\end_layout

\begin_layout Itemize
Encontrar usando las fórmulas para este caso (Caso #2):
\begin_inset Formula 
\[
f(n)\in\theta(n^{log_{2}2}log_{2}^{0}n)\Longrightarrow f(n)\in\theta(n^{log_{2}2}log_{2}^{0+1}n)
\]

\end_inset


\begin_inset Formula 
\[
f(n)\in\theta(n)\Longrightarrow fn(n)\in\theta(n*log_{2}n)
\]

\end_inset


\end_layout

\begin_layout Subsubsection
Peor Caso
\end_layout

\begin_layout Standard
Este peor caso se da cuando el algoritmo se divide en 2 subsecciónes en
 donde una es de tamaño 
\begin_inset Formula $S'=1$
\end_inset

 y la otra es de tamaño 
\begin_inset Formula $S'=n-1$
\end_inset

.
 Esto tendria que repetirse todas las veces, quedando subsecciones de tamaño
 
\begin_inset Formula $n-2,n-3,n-4,\ldots$
\end_inset


\end_layout

\begin_layout Standard
Teniendo en cuenta ese contexto podemos concluir que la función de recurrencia
 es la siguiente:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=2T(n-1)+O(n)\Longrightarrow O(n^{2})
\]

\end_inset


\begin_inset Formula 
\[
T(n)=\frac{n*(n-1)}{2}\Longrightarrow n^{2}
\]

\end_inset


\end_layout

\begin_layout Subsection
Invariante
\end_layout

\begin_layout Standard
Al analizar el algoritmo de QuickSort, identificamos que el invariante crítico
 reside en el procedimiento de partición.
 Este procedimiento presenta un ciclo que define la ordenación de la secuencia.
\end_layout

\begin_layout Standard
El invariante fundamental en QuickSort establece que, después de cada operación
 de partición, el pivote ocupa su posición final en la lista ordenada.
 Formalmente, en la sublista 
\begin_inset Formula $S'[1:pivote-1]$
\end_inset

 son menores o iguales al pivote, y todos los elementos en la sublista a
 
\begin_inset Formula $S'[pivote+1:fin]$
\end_inset

 son mayores o iguales al pivote.
 Entonces, el invariante puede expresarse como: 
\begin_inset Formula 
\[
S'(1,pivotIndex−1)<pivote<S'(pivotIndex+1,fin)
\]

\end_inset


\end_layout

\begin_layout Standard
Donde 
\begin_inset Formula $pivotIndex$
\end_inset

 es la posición final del pivote después de la partición.
 Este invariante garantiza que, en cada paso, la lista se divide en dos
 sublistas que cumplen con las condiciones de orden en relación con el pivote
 (los menores a la izquierda y los mayores a la derecha).
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Inicio
\series default
\bar default
: Al comenzar el algoritmo, antes de realizar cualquier partición, el invariante
 se establece.
 Sea 
\begin_inset Formula $S[1:n]$
\end_inset

 la lista completa a ordenar, y 
\begin_inset Formula $i$
\end_inset

 la posición del pivote antes de realizar la primera partición.
 En este momento, el invariante es: 
\begin_inset Formula $P(0,i−1)∧P(i+1,n)∧a[i]=pivote$
\end_inset

 Donde 
\begin_inset Formula $P(0,i−1)$
\end_inset

 y 
\begin_inset Formula $P(i+1,n)$
\end_inset

 indican que las sublistas a la izquierda y a la derecha del pivote, respectivam
ente, están inicialmente vacías.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Avance
\series default
\bar default
: Después de realizar una partición en la posición 
\begin_inset Formula $i$
\end_inset

, el invariante se mantiene.
 Se elige un pivote y se reorganizan los elementos de la lista de modo que
 los elementos a la izquierda del pivote sean menores o iguales, y los elementos
 a la derecha sean mayores o iguales.
 El invariante después del avance es: 
\begin_inset Formula $P(0,i−1)∧P(i+1,n)∧a[i]=pivote$
\end_inset

 Donde 
\begin_inset Formula $P(0,i−1)$
\end_inset

 y 
\begin_inset Formula $P(i+1,n)$
\end_inset

 indican que las sublistas a la izquierda y a la derecha del pivote, respectivam
ente, cumplen con las condiciones de orden establecidas por el pivote después
 de la partición.
\end_layout

\begin_layout Itemize

\series bold
\bar under
\lang spanish
Terminación: 
\series default
\bar default
Cuando el algoritmo termina, todas las particiones han sido realizadas y
 la lista está completamente ordenada.
 En este punto, el invariante final es: 
\begin_inset Formula 
\[
P(1,n)
\]

\end_inset

 Esto significa que toda la lista cumple con las condiciones de orden, ya
 que la lista se ha dividido y ordenado correctamente en cada partición.
\end_layout

\begin_layout Subsection
Notas de Implementación
\end_layout

\begin_layout Standard
Para la implementación de este algoritmo se hizo uso del lenguaje interpretado
 Python.
 En este caso, se nos brindó dicho código que fue escrito por el profesor
 Leonardo Flórez El código para este algoritmo se ubica en la carpeta 
\begin_inset Formula $‘Código/Taller1–Análisisdealgoritmos/sort/quicksort.py’$
\end_inset

.
 
\end_layout

\begin_layout Standard
La implementación se encuentra entre la línea 12 y la 22.
 
\end_layout

\begin_layout Part

\lang spanish
Comparación de los algoritmos
\end_layout

\begin_layout Section

\lang spanish
Ejecución de los algoritmos:
\end_layout

\begin_layout Standard

\lang spanish
Para poder realizar estas comparaciones se corrió el programa “main.py”.
 En este programa podemos comparar los 3 tipos de algortimos y de esta manera,
 poder realizar una comparación con ayuda de gráficas y los mismos outputs
 que nos brinda el código.
 Para poder realizar las pruebas hemos creado un archivo llamado 
\begin_inset Formula $\mathbf{data.res}$
\end_inset

 con los siguientes argumentos: 
\begin_inset Formula 
\[
min\char`_{s}=1
\]

\end_inset


\begin_inset Formula 
\[
max\char`_{s}=5000
\]

\end_inset


\begin_inset Formula 
\[
step=100
\]

\end_inset


\end_layout

\begin_layout Standard

\lang spanish
Con esos argumentos fuimos capaces de obtener la siguiente gráfica: 
\end_layout

\begin_layout Standard

\lang spanish
\begin_inset Graphics
	filename Imágenes/Tiempos de ejecución de algoritmos.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard

\lang spanish
En la tabla anterior se puede apreciar de manera interpretativa que para
 el algoritmo de Bubble Sort, Insertion Sort & Quick Sort.
 Estos se comportan de manera similar a su complejidad algoritmica en el
 peor caso; siendo 
\begin_inset Formula $O(n^{2})$
\end_inset

 para BubbleSort, 
\begin_inset Formula $O(n^{2})$
\end_inset

 para el InsertionSort y 
\begin_inset Formula $O(n*log(n))$
\end_inset

 para el QuickSort.
\end_layout

\begin_layout Standard
Ahora, podemos ver que aunque ambos Bubble Sort e Insertion Sort tienen
 una complejidad asintótica cuadrática (
\begin_inset Formula $O(n^{2})$
\end_inset

), la diferencia clave en su rendimiento radica en cómo manejan el intercambio
 de elementos.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{En Bubble Sort, se realizan intercambios continuos entre elementos
 adyacentes hasta que todo el conjunto esté ordenado}
\end_layout

\end_inset

,lo que puede resultar en un alto número de operaciones incluso en conjuntos
 parcialmente ordenados.
 Por otro lado, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textbf{Insertion Sort construye gradualmente la parte ordenada del conjunto,
 desplazando elementos solo cuando es necesario para insertar el siguiente
 elemento en su posición correcta.}
\end_layout

\end_inset

 Esto implica que Insertion Sort tiende a ser más eficiente, especialmente
 en conjuntos de datos parcialmente ordenados, ya que puede detenerse temprano
 en cada iteración si encuentra que un elemento ya está en su lugar correcto,
 lo que reduce el número total de comparaciones e intercambios en comparación
 con Bubble Sort.
\end_layout

\begin_layout Subsection
BubbleSort
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Imágenes/Output - BubbleSort.png
	scale 85
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Con un 
\begin_inset Formula $R^{2}=1$
\end_inset

, podemos afirmar que el modelo de la regresión se ajusta a 
\begin_inset Formula $n^{2}$
\end_inset

 y que la variabilidad es explicada por las variables del modelo.
 El modelo explica toda la variabilidad en la variable dependiente.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Imágenes/Gráfica - BubbleSort.png
	scale 80

\end_inset


\end_layout

\begin_layout Standard
Ya con la gráfica podemos ver la similitud de la simulación con la función
 
\begin_inset Formula $n^{2}$
\end_inset

.
\end_layout

\begin_layout Subsection
InsertionSort
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Imágenes/Output - InsertionSort.png
	scale 80
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Con un 
\begin_inset Formula $R^{2}=1$
\end_inset

, podemos afirmar que el modelo de la regresión se ajusta a 
\begin_inset Formula $n^{2}$
\end_inset

 y que la variabilidad es explicada por las variables del modelo.
 El modelo explica toda la variabilidad en la variable dependiente.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Imágenes/Gráfica - InsertionSort.png
	scale 75
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
De manera similar al Bubble Sort, vemos la concordancia de la simulación
 con la función 
\begin_inset Formula $n^{2}$
\end_inset

.
 Para este caso se ve un poco más de variación, pero esta es insignificante.
\end_layout

\begin_layout Subsection
QuickSort
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Imágenes/Output - QuickSort.png
	scale 85
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Con un 
\begin_inset Formula $R^{2}=0.996$
\end_inset

, podemos afirmar que el modelo de la regresión se ajusta de manera extremadamen
te precisa a 
\begin_inset Formula $n*log(n)$
\end_inset

 y que la variabilidad es explicada en gran parte por las variables del
 modelo.
 El modelo explica casi toda la variabilidad en la variable dependiente.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename Imágenes/Gráfica - QuickSort.png
	scale 75

\end_inset


\end_layout

\begin_layout Standard
En este caso, se observa mayor variabilidad pequeña pero suficiente para
 que 
\begin_inset Formula $R^{2}\neq1.00$
\end_inset

.
 De igual manera, vemos que esta no altera el comportamiento del experimento
 con el 
\begin_inset Formula $n*log(n)$
\end_inset

 en la regresión, por lo cual se puede explicar el 
\begin_inset Formula $R^{2}=0.996$
\end_inset

 el cual es bastante preciso.
\end_layout

\end_body
\end_document
